// Table-driven pattern generation from dialog_patterns.toml
// Replaces 700+ lines of duplicated pattern code with declarative approach

use anyhow::Result;
use serde::Deserialize;
use std::collections::HashMap;
use std::env;
use std::fs;
use std::path::Path;

#[derive(Deserialize)]
struct SeamConfig {
    components: HashMap<String, String>,
    character_classes: HashMap<String, CharacterClassConfig>,
    dialog_states: HashMap<String, DialogStateConfig>,
    pattern_templates: Vec<PatternTemplate>,
}

#[derive(Deserialize)]
struct CharacterClassConfig {
    value: String,
    format: String,
}

#[derive(Deserialize)]
struct DialogStateConfig {
    open: String,
    close: String,
    state_name: String,
}

#[derive(Deserialize)]
struct PatternTemplate {
    name: String,
    regex: String,
    match_type: String,
    next_state: String,
}

fn main() -> Result<()> {
    let config: SeamConfig = toml::from_str(include_str!("dialog_patterns.toml"))?;
    let out_dir = env::var("OUT_DIR")?;
    let dest_path = Path::new(&out_dir).join("generated_dialog_patterns.rs");
    
    // Validate all regex patterns compile
    println!("cargo:warning=Validating {} pattern templates...", config.pattern_templates.len());
    for template in &config.pattern_templates {
        // Test pattern expansion with first dialog state to catch syntax errors early
        if let Some((_, first_state)) = config.dialog_states.iter().next() {
            let test_pattern = expand_template_for_validation(template, first_state, &config.components, &config.character_classes)?;
            regex_automata::meta::Regex::new(&test_pattern)
                .map_err(|e| anyhow::anyhow!("Invalid regex in template '{}': {} (expanded: '{}')", template.name, e, test_pattern))?;
        }
    }
    
    let mut code = String::new();
    
    // Generate imports and function signature
    code.push_str("// Auto-generated from dialog_patterns.toml - DO NOT EDIT\n\n");
    
    code.push_str("pub fn create_generated_dialog_patterns() -> Result<(HashMap<DialogState, Regex>, HashMap<DialogState, Vec<(MatchType, DialogState)>>)> {\n");
    code.push_str("    let mut state_patterns = HashMap::new();\n");
    code.push_str("    let mut state_pattern_mappings = HashMap::new();\n\n");
    
    // Add component definitions from TOML using raw strings
    code.push_str("    // Pattern components from dialog_patterns.toml\n");
    for (key, value) in &config.components {
        code.push_str(&format!("    let {} = r#\"{}\"#;\n", key, value));
    }
    
    // Add character class variables that will be used in format strings
    code.push_str("    // Character class variables for format strings\n");
    for (key, char_class) in &config.character_classes {
        match char_class.format.as_str() {
            "as_class" => {
                code.push_str(&format!("    let {} = r#\"{}\"#;\n", key, char_class.value));
            }
            "as_negated_class" => {
                code.push_str(&format!("    let {} = r#\"[^{}]\"#;\n", key, char_class.value));
            }
            "as_class_inner" => {
                // Extract inner content from character class
                let inner = if char_class.value.starts_with('[') && char_class.value.ends_with(']') {
                    &char_class.value[1..char_class.value.len()-1]
                } else {
                    &char_class.value
                };
                code.push_str(&format!("    let {} = r#\"{}\"#;\n", key, inner));
            }
            _ => {
                return Err(anyhow::anyhow!("Unknown character class format: {}", char_class.format));
            }
        }
    }
    code.push_str("\n");
    
    // Generate narrative patterns (these are not templated)
    generate_narrative_patterns(&mut code, &config)?;
    
    // Generate dialog state patterns using templates
    for (state_key, state_config) in &config.dialog_states {
        generate_dialog_state_patterns(&mut code, state_key, state_config, &config)?;
    }
    
    code.push_str("    Ok((state_patterns, state_pattern_mappings))\n");
    code.push_str("}\n");
    
    fs::write(&dest_path, code)?;
    
    println!("cargo:rerun-if-changed=dialog_patterns.toml");
    Ok(())
}


fn generate_narrative_patterns(code: &mut String, config: &SeamConfig) -> Result<()> {
    code.push_str("    // NARRATIVE STATE patterns\n");
    code.push_str("    let narrative_sentence_boundary = format!(r#\"{}({}){}\"#, sentence_end_punct, soft_separator, non_dialog_sentence_start_chars);\n");
    code.push_str("    let narrative_line_boundary = format!(r#\"{}{}{}\"#, sentence_end_punct, line_boundary, non_dialog_sentence_start_chars);\n");
    code.push_str("    let narrative_hard_boundary = format!(r#\"{}\\s*{}\\s*{}\"#, sentence_end_punct, hard_separator, non_dialog_sentence_start_chars);\n");
    code.push_str("    let pure_hard_sep = hard_separator;\n\n");
    
    // Generate N→D transitions for each dialog state
    code.push_str("    // N→D transitions\n");
    for (state_key, state_config) in &config.dialog_states {
        let open_char = state_config.open.replace("{", "{{").replace("}", "}}");
        code.push_str(&format!("    let narrative_to_{}_boundary = format!(r#\"{{}}({{}}){}\"#, sentence_end_punct, soft_separator);\n", state_key, open_char));
        code.push_str(&format!("    let narrative_to_{}_no_boundary = format!(r#\"{{}}({{}}){}\"#, non_sentence_ending_punct, soft_separator);\n", state_key, open_char));
        code.push_str(&format!("    let {}_independent = format!(r#\"{{}}{}\"#, dialog_prefix_whitespace);\n", state_key, open_char));
    }
    code.push_str("\n");
    
    // Build narrative patterns vector
    code.push_str("    let narrative_patterns = vec![\n");
    for (state_key, _) in &config.dialog_states {
        code.push_str(&format!("        narrative_to_{}_boundary.as_str(),\n", state_key));
        code.push_str(&format!("        narrative_to_{}_no_boundary.as_str(),\n", state_key));
        code.push_str(&format!("        {}_independent.as_str(),\n", state_key));
    }
    code.push_str("        narrative_line_boundary.as_str(),\n");
    code.push_str("        narrative_sentence_boundary.as_str(),\n");
    code.push_str("        narrative_hard_boundary.as_str(),\n");
    code.push_str("        pure_hard_sep,\n");
    code.push_str("    ];\n\n");
    
    // Build narrative mappings vector
    code.push_str("    let narrative_mappings = vec![\n");
    for (_state_key, state_config) in &config.dialog_states {
        code.push_str(&format!("        (MatchType::NarrativeToDialog, DialogState::{}),\n", state_config.state_name));
        code.push_str(&format!("        (MatchType::DialogOpen, DialogState::{}),\n", state_config.state_name));
        code.push_str(&format!("        (MatchType::DialogOpen, DialogState::{}),\n", state_config.state_name));
    }
    code.push_str("        (MatchType::NarrativeGestureBoundary, DialogState::Narrative),\n");
    code.push_str("        (MatchType::NarrativeGestureBoundary, DialogState::Narrative),\n");
    code.push_str("        (MatchType::NarrativeGestureBoundary, DialogState::Narrative),\n");
    code.push_str("        (MatchType::HardSeparator, DialogState::Unknown),\n");
    code.push_str("    ];\n\n");
    
    code.push_str("    state_patterns.insert(DialogState::Narrative, Regex::new_many(&narrative_patterns)?);\n");
    code.push_str("    state_pattern_mappings.insert(DialogState::Narrative, narrative_mappings);\n\n");
    
    Ok(())
}

fn generate_dialog_state_patterns(
    code: &mut String, 
    state_key: &str, 
    state_config: &DialogStateConfig, 
    config: &SeamConfig
) -> Result<()> {
    code.push_str(&format!("    // {} patterns\n", state_config.state_name));
    
    let mut patterns = Vec::new();
    let mut mappings = Vec::new();
    
    // Hard separator pattern (same for all states)
    patterns.push("pure_hard_sep".to_string());
    mappings.push("(MatchType::HardSeparator, DialogState::Unknown)".to_string());
    
    // Apply each pattern template to this dialog state
    for template in &config.pattern_templates {
        let pattern_var = format!("{}_{}", state_key, template.name);
        
        // Check if this template uses character class variables
        let template_regex = &template.regex;
        let uses_char_classes = config.character_classes.keys().any(|key| {
            template_regex.contains(&format!("[{{{}}}]", key)) || 
            template_regex.contains(&format!("{{{}}}", key)) ||
            template_regex.contains(&format!("[^{{{}}}]", key))
        });
        
        // Always use fully expanded patterns to avoid clippy warnings from format! calls
        let expanded_pattern = expand_template_for_validation(template, state_config, &config.components, &config.character_classes)?;
        code.push_str(&format!("    let {} = r#\"{}\"#;\n", pattern_var, expanded_pattern));
        patterns.push(pattern_var.clone());
        
        let next_state = match template.next_state.as_str() {
            "Narrative" => "DialogState::Narrative".to_string(),
            "Unknown" => "DialogState::Unknown".to_string(),
            _ => format!("DialogState::{}", template.next_state),
        };
        
        mappings.push(format!("(MatchType::{}, {})", template.match_type, next_state));
    }
    
    code.push_str(&format!("    let {}_patterns = vec![\n", state_key));
    for pattern in &patterns {
        code.push_str(&format!("        {},\n", pattern));
    }
    code.push_str("    ];\n\n");
    
    code.push_str(&format!("    let {}_mappings = vec![\n", state_key));
    for mapping in &mappings {
        code.push_str(&format!("        {},\n", mapping));
    }
    code.push_str("    ];\n\n");
    
    code.push_str(&format!("    state_patterns.insert(DialogState::{}, Regex::new_many(&{}_patterns)?);\n", state_config.state_name, state_key));
    code.push_str(&format!("    state_pattern_mappings.insert(DialogState::{}, {}_mappings);\n\n", state_config.state_name, state_key));
    
    Ok(())
}

fn expand_template_to_format_string(
    template: &PatternTemplate,
    state: &DialogStateConfig,
    components: &HashMap<String, String>,
    character_classes: &HashMap<String, CharacterClassConfig>
) -> Result<String> {
    let mut pattern = template.regex.clone();
    
    // Replace state-specific placeholders and escape curly braces in Unicode escapes
    let open_escaped = state.open.replace("{", "{{").replace("}", "}}");
    let close_escaped = state.close.replace("{", "{{").replace("}", "}}");
    pattern = pattern.replace("{open}", &open_escaped);
    pattern = pattern.replace("{close}", &close_escaped);
    
    // Replace regular component placeholders and escape curly braces in Unicode escapes
    for (key, value) in components {
        let value_escaped = value.replace("{", "{{").replace("}", "}}");
        pattern = pattern.replace(&format!("{{{}}}", key), &value_escaped);
    }
    
    // Replace character class placeholders with format placeholders
    for (key, char_class) in character_classes {
        match char_class.format.as_str() {
            "as_class" => {
                pattern = pattern.replace(&format!("[{{{}}}]", key), "[{}]");
            }
            "as_negated_class" => {
                pattern = pattern.replace(&format!("{{{}}}", key), "{}");
            }
            "as_class_inner" => {
                pattern = pattern.replace(&format!("{{{}}}", key), "{}");
                pattern = pattern.replace(&format!("[^{{{}}}]", key), "[^{}]");
            }
            _ => {}
        }
    }
    
    Ok(pattern)
}

fn get_format_args(template: &PatternTemplate, character_classes: &HashMap<String, CharacterClassConfig>) -> String {
    let template_regex = &template.regex;
    let mut args = Vec::new();
    
    for (key, char_class) in character_classes {
        match char_class.format.as_str() {
            "as_class" => {
                if template_regex.contains(&format!("[{{{}}}]", key)) {
                    args.push(key.clone());
                }
            }
            "as_negated_class" => {
                if template_regex.contains(&format!("{{{}}}", key)) {
                    args.push(key.clone());
                }
            }
            "as_class_inner" => {
                let uses_plain = template_regex.contains(&format!("{{{}}}", key));
                let uses_negated = template_regex.contains(&format!("[^{{{}}}]", key));
                if uses_plain || uses_negated {
                    // Only add the argument once, even if used in multiple contexts
                    if !args.contains(&key) {
                        args.push(key.clone());
                    }
                }
            }
            _ => {}
        }
    }
    
    args.join(", ")
}

fn expand_template_for_validation(
    template: &PatternTemplate,
    state: &DialogStateConfig,
    components: &HashMap<String, String>,
    character_classes: &HashMap<String, CharacterClassConfig>
) -> Result<String> {
    let mut pattern = template.regex.clone();
    
    // Replace state-specific placeholders
    pattern = pattern.replace("{open}", &state.open);
    pattern = pattern.replace("{close}", &state.close);
    
    // Replace regular component placeholders
    for (key, value) in components {
        pattern = pattern.replace(&format!("{{{}}}", key), value);
    }
    
    // Replace character class placeholders for validation
    for (key, char_class) in character_classes {
        match char_class.format.as_str() {
            "as_class" => {
                pattern = pattern.replace(&format!("[{{{}}}]", key), &format!("[{}]", char_class.value));
            }
            "as_negated_class" => {
                pattern = pattern.replace(&format!("{{{}}}", key), &format!("[^{}]", char_class.value));
            }
            "as_class_inner" => {
                let inner = if char_class.value.starts_with('[') && char_class.value.ends_with(']') {
                    &char_class.value[1..char_class.value.len()-1]
                } else {
                    &char_class.value
                };
                pattern = pattern.replace(&format!("{{{}}}", key), inner);
                pattern = pattern.replace(&format!("[^{{{}}}]", key), &format!("[^{}]", inner));
            }
            _ => {}
        }
    }
    
    Ok(pattern)
}

fn expand_template(
    template: &PatternTemplate,
    state: &DialogStateConfig,
    components: &HashMap<String, String>
) -> Result<String> {
    let mut pattern = template.regex.clone();
    
    // Replace state-specific placeholders
    pattern = pattern.replace("{open}", &state.open);
    pattern = pattern.replace("{close}", &state.close);
    
    // Replace component placeholders
    for (key, value) in components {
        pattern = pattern.replace(&format!("{{{}}}", key), value);
    }
    
    Ok(pattern)
}